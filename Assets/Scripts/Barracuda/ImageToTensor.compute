// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel mainZeroBorder
#pragma kernel mainRepeat

RWTexture2D<float4> output_texture;

Texture2D<float4> input_data;

SamplerState sampler_input_data_linear_clamp;

RWStructuredBuffer<float> output_data;

int2 out_size;

float alpha;

float beta;

float4x4 transform_matrix;

[numthreads(8, 8, 1)]
void mainZeroBorder(uint3 id : SV_DispatchThreadID)
{
    int1 out_width = out_size.x;
    int1 out_height = out_size.y;

    int2 gid = int2(id.xy);
    if (gid.x >= out_width || gid.y >= out_height)
    {
        return;
    }

    // transform from image.width, image.height range to [0, 1] (UV)
    float normal_x = (float(gid.x) + 0.5f) / float(out_width);
    float normal_y = (float(gid.y) + 0.5f) / float(out_height);
    float4 tc = float4(normal_x, normal_y, 0.0, 1.0);

    // Apply transformation from roi coordinates to original image coordinates.
    tc = mul(transform_matrix, tc);

    // Opengl texture sampler has origin in lower left corner,
    // DirectX origin in upper left corner
    // tc.y = 1 - tc.y;

    float4 src_value = alpha * input_data.SampleLevel(sampler_input_data_linear_clamp, tc.xy, 0) + beta;

    float out_of_bounds = float(tc.x < 0.0 || tc.x > 1.0 || tc.y < 0.0 || tc.y > 1.0);
    src_value = lerp(src_value, float4(0.0, 0.0, 0.0, 0.0), out_of_bounds);

    output_texture[gid.xy] = src_value;

    int linear_index = gid.y * out_width + gid.x;

    // output_data.elements is populated as though it contains float3 elements.
    int first_component_index = 3 * linear_index;
    output_data[first_component_index] = src_value.r;
    output_data[first_component_index + 1] = src_value.g;
    output_data[first_component_index + 2] = src_value.b;
}

[numthreads(8, 8, 1)]
void mainRepeat(uint3 id : SV_DispatchThreadID)
{
    int1 out_width = out_size.x;
    int1 out_height = out_size.y;

    int2 gid = int2(id.xy);
    if (gid.x >= out_width || gid.y >= out_height)
    {
        return;
    }

    // transform from image.width, image.height range to [0, 1] (UV)
    float normal_x = (float(gid.x) + 0.5f) / float(out_width);
    float normal_y = (float(gid.y) + 0.5f) / float(out_height);
    float4 tc = float4(normal_x, normal_y, 0.0, 1.0);

    // Apply transformation from roi coordinates to original image coordinates.
    tc = mul(transform_matrix, tc);

    // Opengl texture sampler has origin in lower left corner,
    // DirectX origin in upper left corner
    // tc.y = 1 - tc.y;

    float4 src_value = alpha * input_data.SampleLevel(sampler_input_data_linear_clamp, tc.xy, 0) + beta;

    output_texture[gid.xy] = src_value;

    int linear_index = gid.y * out_width + gid.x;

    // output_data.elements is populated as though it contains float3 elements.
    int first_component_index = 3 * linear_index;
    output_data[first_component_index] = src_value.r;
    output_data[first_component_index + 1] = src_value.g;
    output_data[first_component_index + 2] = src_value.b;
}