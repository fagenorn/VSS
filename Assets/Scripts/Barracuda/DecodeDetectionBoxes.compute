// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel main

StructuredBuffer<float> raw_boxes;

StructuredBuffer<float> raw_anchors;

RWStructuredBuffer<float> boxes;

float4 scale;

uint num_coords;

int reverse_output_order;

int apply_exponential;

int box_coord_offset;

int num_keypoints;

int keypt_coord_offset;

int num_values_per_keypt;

[numthreads(1, 1, 1)]
void main(uint3 id : SV_DispatchThreadID)
{
    uint g_idx = id.x; // box index
    uint box_offset = g_idx * num_coords + uint(box_coord_offset);
    uint anchor_offset = g_idx * uint(4); // check kNumCoordsPerBox

    float y_center, x_center, h, w;

    if (reverse_output_order == int(0))
    {
        y_center = raw_boxes[box_offset + uint(0)];
        x_center = raw_boxes[box_offset + uint(1)];
        h = raw_boxes[box_offset + uint(2)];
        w = raw_boxes[box_offset + uint(3)];
    }
    else
    {
        x_center = raw_boxes[box_offset + uint(0)];
        y_center = raw_boxes[box_offset + uint(1)];
        w = raw_boxes[box_offset + uint(2)];
        h = raw_boxes[box_offset + uint(3)];
    }

    float anchor_yc = raw_anchors[anchor_offset + uint(0)];
    float anchor_xc = raw_anchors[anchor_offset + uint(1)];
    float anchor_h = raw_anchors[anchor_offset + uint(2)];
    float anchor_w = raw_anchors[anchor_offset + uint(3)];

    x_center = x_center / scale.x * anchor_w + anchor_xc;
    y_center = y_center / scale.y * anchor_h + anchor_yc;

    if (apply_exponential == int(1))
    {
        h = exp(h / scale.w) * anchor_h;
        w = exp(w / scale.z) * anchor_w;
    }
    else
    {
        h = (h / scale.w) * anchor_h;
        w = (w / scale.z) * anchor_w;
    }

    float ymin = y_center - h / 2.0;
    float xmin = x_center - w / 2.0;
    float ymax = y_center + h / 2.0;
    float xmax = x_center + w / 2.0;

    boxes[box_offset + uint(0)] = ymin;
    boxes[box_offset + uint(1)] = xmin;
    boxes[box_offset + uint(2)] = ymax;
    boxes[box_offset + uint(3)] = xmax;

    if (num_keypoints > int(0))
    {
        for (int k = 0; k < num_keypoints; ++k)
        {
            int kp_offset = int(g_idx * num_coords) + keypt_coord_offset + k * num_values_per_keypt;
            float kp_y, kp_x;
            if (reverse_output_order == int(0))
            {
                kp_y = raw_boxes[kp_offset + int(0)];
                kp_x = raw_boxes[kp_offset + int(1)];
            }
            else
            {
                kp_x = raw_boxes[kp_offset + int(0)];
                kp_y = raw_boxes[kp_offset + int(1)];
            }
            boxes[kp_offset + int(0)] = kp_x / scale.x * anchor_w + anchor_xc;
            boxes[kp_offset + int(1)] = kp_y / scale.y * anchor_h + anchor_yc;
        }
    }
}
