input_stream: "input_video"

input_side_packet: "REFINE_FACE_LANDMARKS:refine_face_landmarks"

output_stream: "FACE_LANDMARKS:face_landmarks"

node {
  calculator: "FlowLimiterCalculator"
  input_stream: "input_video"
  input_stream: "FINISHED:face_landmarks"
  input_stream_info: {
    tag_index: "FINISHED"
    back_edge: true
  }
  output_stream: "throttled_input_video"
  node_options: {
    [type.googleapis.com/mediapipe.FlowLimiterCalculatorOptions] {
      max_in_flight: 1
      max_in_queue: 1
      # Timeout is disabled (set to 0) as first frame processing can take more
      # than 1 second.
      in_flight_timeout: 0
    }
  }
}

node: {
  calculator: "ImageTransformationCalculator"
  input_stream: "IMAGE:throttled_input_video"
  input_side_packet: "ROTATION_DEGREES:input_rotation"
  input_side_packet: "FLIP_HORIZONTALLY:input_horizontally_flipped"
  input_side_packet: "FLIP_VERTICALLY:input_vertically_flipped"
  output_stream: "IMAGE:transformed_input_video"
}

node: {
  calculator: "ToImageCalculator"
  input_stream: "IMAGE_CPU:transformed_input_video"
  output_stream: "IMAGE:multi_backend_image"
}

node: {
  calculator: "ImageToTensorCalculator"
  input_stream: "IMAGE:multi_backend_image"
  output_stream: "TENSORS:input_tensors_first"
  output_stream: "MATRIX:transform_matrix"
  options: {
    [mediapipe.ImageToTensorCalculatorOptions.ext] {
      output_tensor_width: 128
      output_tensor_height: 128
      keep_aspect_ratio: true
      output_tensor_float_range {
        min: -1.0
        max: 1.0
      }
      border_mode: BORDER_ZERO
    }
  }
}

node {
  calculator: "InferenceCalculator"
  input_stream: "TENSORS:input_tensors_first"
  output_stream: "TENSORS:detection_tensors"
  options: {
    [mediapipe.InferenceCalculatorOptions.ext] {
      model_path: "mediapipe/modules/face_detection/face_detection_short_range.tflite"
      delegate { xnnpack {} }
    }
  }
}

node {
  calculator: "SsdAnchorsCalculator"
  output_side_packet: "anchors"
  options: {
    [mediapipe.SsdAnchorsCalculatorOptions.ext] {
      num_layers: 4
      min_scale: 0.1484375
      max_scale: 0.75
      input_size_height: 128
      input_size_width: 128
      anchor_offset_x: 0.5
      anchor_offset_y: 0.5
      strides: 8
      strides: 16
      strides: 16
      strides: 16
      aspect_ratios: 1.0
      fixed_anchor_size: true
    }
  }
}

node {
  calculator: "TensorsToDetectionsCalculator"
  input_stream: "TENSORS:detection_tensors"
  input_side_packet: "ANCHORS:anchors"
  output_stream: "DETECTIONS:unfiltered_detections"
  options: {
    [mediapipe.TensorsToDetectionsCalculatorOptions.ext] {
      num_classes: 1
      num_boxes: 896
      num_coords: 16
      box_coord_offset: 0
      keypoint_coord_offset: 4
      num_keypoints: 6
      num_values_per_keypoint: 2
      sigmoid_score: true
      score_clipping_thresh: 100.0
      reverse_output_order: true
      x_scale: 128.0
      y_scale: 128.0
      h_scale: 128.0
      w_scale: 128.0
      min_score_thresh: 0.5
    }
  }
}

node {
  calculator: "NonMaxSuppressionCalculator"
  input_stream: "unfiltered_detections"
  output_stream: "filtered_detections"
  options: {
    [mediapipe.NonMaxSuppressionCalculatorOptions.ext] {
      min_suppression_threshold: 0.3
      overlap_type: INTERSECTION_OVER_UNION
      algorithm: WEIGHTED
    }
  }
}

node {
  calculator: "DetectionProjectionCalculator"
  input_stream: "DETECTIONS:filtered_detections"
  input_stream: "PROJECTION_MATRIX:transform_matrix"
  output_stream: "DETECTIONS:face_detection"
}

node {
  calculator: "ImagePropertiesCalculator"
  input_stream: "IMAGE:multi_backend_image"
  output_stream: "SIZE:multi_backend_image_size"
}

node {
  calculator: "DetectionsToRectsCalculator"
  input_stream: "DETECTIONS:face_detection"
  input_stream: "IMAGE_SIZE:multi_backend_image_size"
  output_stream: "NORM_RECT:raw_roi"
  options: {
    [mediapipe.DetectionsToRectsCalculatorOptions.ext] {
      rotation_vector_start_keypoint_index: 0  # Right eye.
      rotation_vector_end_keypoint_index: 1  # Left eye.
      rotation_vector_target_angle_degrees: 0
      conversion_mode: USE_KEYPOINTS
    }
  }
}

# Expands and shifts the rectangle that contains the face so that it's likely
# to cover the entire face.
node {
  calculator: "RectTransformationCalculator"
  input_stream: "NORM_RECT:raw_roi"
  input_stream: "IMAGE_SIZE:multi_backend_image_size"
  output_stream: "face_rect_from_detection"
  options: {
    [mediapipe.RectTransformationCalculatorOptions.ext] {
      scale_x: 2.0
      scale_y: 2.0
      shift_y: -0.1
      square_long: true
    }
  }
}

node: {
  calculator: "ImageToTensorCalculator"
  input_stream: "IMAGE:multi_backend_image"
  input_stream: "NORM_RECT:face_rect_from_detection"
  output_stream: "TENSORS:input_tensors_second"
  options: {
    [mediapipe.ImageToTensorCalculatorOptions.ext] {
      output_tensor_width: 192
      output_tensor_height: 192
      output_tensor_float_range {
        min: 0.0
        max: 1.0
      }
    }
  }
}

node {
  calculator: "FaceLandmarksModelLoader"
  input_side_packet: "WITH_ATTENTION:refine_face_landmarks"
  output_side_packet: "MODEL:model"
}

node {
  calculator: "TfLiteCustomOpResolverCalculator"
  output_side_packet: "op_resolver"
}

node {
  calculator: "InferenceCalculator"
  input_stream: "TENSORS:input_tensors_second"
  input_side_packet: "MODEL:model"
  input_side_packet: "CUSTOM_OP_RESOLVER:op_resolver"
  output_stream: "TENSORS:output_tensors_face_landmarks"
  options: {
    [mediapipe.InferenceCalculatorOptions.ext] {
      delegate { xnnpack {} }
    }
  }
}

node {
  calculator: "SwitchContainer"
  input_side_packet: "ENABLE:refine_face_landmarks"
  input_stream: "output_tensors_face_landmarks"
  output_stream: "landmark_tensors"
  output_stream: "face_flag_tensor"
  options: {
    [mediapipe.SwitchContainerOptions.ext] {
      contained_node: {
        calculator: "SplitTensorVectorCalculator"
        options: {
          [mediapipe.SplitVectorCalculatorOptions.ext] {
            ranges: { begin: 0 end: 1 }
            ranges: { begin: 1 end: 2 }
          }
        }
      }
      contained_node: {
        calculator: "SplitTensorVectorCalculator"
        options: {
          [mediapipe.SplitVectorCalculatorOptions.ext] {
            ranges: { begin: 0 end: 6 }
            ranges: { begin: 6 end: 7 }
          }
        }
      }
    }
  }
}

node {
  calculator: "TensorsToFloatsCalculator"
  input_stream: "TENSORS:face_flag_tensor"
  output_stream: "FLOAT:face_presence_score"
  options {
    [mediapipe.TensorsToFloatsCalculatorOptions.ext] {
      activation: SIGMOID
    }
  }
}

node {
  calculator: "ThresholdingCalculator"
  input_stream: "FLOAT:face_presence_score"
  output_stream: "FLAG:face_presence"
  options: {
    [mediapipe.ThresholdingCalculatorOptions.ext] {
      threshold: 0.5
    }
  }
}

node {
  calculator: "GateCalculator"
  input_stream: "landmark_tensors"
  input_stream: "ALLOW:face_presence"
  output_stream: "ensured_landmark_tensors"
}

node {
  calculator: "SwitchContainer"
  input_side_packet: "ENABLE:refine_face_landmarks"
  input_stream: "TENSORS:ensured_landmark_tensors"
  output_stream: "LANDMARKS:landmarks"
  options: {
    [mediapipe.SwitchContainerOptions.ext] {
      contained_node: {
        calculator: "TensorsToFaceLandmarks"
      }
      contained_node: {
        calculator: "TensorsToFaceLandmarksWithAttention"
      }
    }
  }
}

node {
  calculator: "LandmarkProjectionCalculator"
  input_stream: "NORM_LANDMARKS:landmarks"
  input_stream: "NORM_RECT:face_rect_from_detection"
  output_stream: "NORM_LANDMARKS:face_landmarks"
}
